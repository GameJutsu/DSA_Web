[
	{
		"date": "2026-01-01",
		"number": 1929,
		"name": "Concatenation of Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> getConcatenation(vector<int>& nums) {\n        int len=nums.size();\n        vector<int> ans(len*2);\n        for(int i=0; i<len; i++){\n            ans[i]=nums[i];\n            ans[len+i]=nums[i];\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Single pass, time O(n), extra space O(n) for the duplicated array (output-sized).",
		"betterApproach": "This is already optimal; the task requires materializing the doubled array, so no asymptotically better approach exists.",
		"betterComplexity": "Time O(n), space O(n) due to required 2n output size."
	},
	{
		"date": "2026-01-01",
		"number": 66,
		"name": "Plus One",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int len=digits.size();\n        for(int i=len-1; i>=0; i--){\n            if(digits[i]!=9){\n                digits[i]+=1;\n                return digits;\n            }\n            else\n            {\n                if(i==0){\n                    digits[i]=1;\n                    digits.push_back(0);\n                }\n                else digits[i]=0;\n            }\n        }\n        return digits;\n    }\n};",
		"myComplexity": "Iterate backwards. If digit != 9, inc & return. If 9, set to 0. If i==0 is reached (all 9s thus far), set first to 1 and append 0. Time O(n), Space O(1).",
		"betterApproach": "Logic is identical, but cleaner: loop backwards, if <9 inc & return, else set to 0. If loop finishes (all 9s), handle resize/carry outside loop. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 217,
		"name": "Contains Duplicate",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<int,int> um;\n        for(int n:nums){\n            if(++um[n]>1) return true;\n        }\n        return false;\n    }\n};",
		"myComplexity": "Use unordered_map to count freqs. Loop nums, increment count. If count > 1, return true. Time O(n), Space O(n).",
		"betterApproach": "Use unordered_set to track presence, not count. Loop nums, if in set return true, else insert. Slightly less overhead than map. Time O(n), Space O(n).",
		"betterComplexity": "Time O(n), Space O(n)."
	},
	{
		"date": "2026-01-02",
		"number": 961,
		"name": "N-Repeated Element in Size 2N Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        int len=nums.size();\n        unordered_map<int,int> um;\n        for(int i=0; i<len; i++){\n            if(++um[nums[i]]>1) return nums[i];\n        }\n        return -1;\n    }\n};",
		"myComplexity": "Use unordered_map to count freqs. Loop array, increment count. First element to reach count 2 is the answer (since only one repeats). Time O(N), Space O(N).",
		"betterApproach": "Exploit density (element is 50% of array). Check neighbors: nums[i] == nums[i-1] or nums[i-2]. By Pigeonhole Principle, duplicate must appear within distance 2. Time O(N), Space O(1).",
		"betterComplexity": "Time O(N), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 242,
		"name": "Valid Anagram",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        vector<int> vs(26,0), vt(26,0);\n        for(char c:s){\n            vs[c-'a']++;\n        }\n        for(char c:t){\n            vt[c-'a']++;\n        }\n        return vs==vt;\n    }\n};",
		"myComplexity": "Create two freq vectors of size 26. Populate vs for s, vt for t. Return vs==vt. Time O(n), Space O(1).",
		"betterApproach": "Use single freq vector. Check lengths equal. Inc for s, dec for t. If any count < 0 (or !=0 at end), false. Saves one pass and half space. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 1,
		"name": "Two Sum",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int len=nums.size();\n        unordered_map<int,int> um;\n        for(int i=0; i<len; i++){\n            if(um[target-nums[i]]) return {um[target-nums[i]]-1, i};\n            else{\n                um[nums[i]]=i+1;\n            }\n        }\n        return {};\n    }\n};",
		"myComplexity": "Iterate once. Store value->index+1. Check if target-val exists. Return indices. Time O(n), Space O(n).",
		"betterApproach": "This is already the optimal one-pass hash table approach. No asymptotic improvement possible.",
		"betterComplexity": "Time O(n), Space O(n)."
	},
	{
		"date": "2026-01-02",
		"number": 14,
		"name": "Longest Common Prefix",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string ans=strs[0];\n        for(string s:strs){\n            string newAns=\"\";\n            int ansL=ans.size(), currL=s.size();\n            for(int i=0; i<ansL, i<currL; i++){\n                if(ans[i]==s[i]) newAns+=ans[i];\n                else break;\n            }\n            if(newAns==\"\") return \"\";\n            ans=newAns;\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Init ans=strs[0]. Loop others, compare with ans char-by-char, rebuilding newAns. Update ans. Time O(S) (sum of chars), Space O(S) (temp strings).",
		"betterApproach": "Sort the strings. Compare only the first and last string (smallest & largest lexicographically). The common prefix of these two is the answer for all. Time O(N*L*logN), Space O(1).",
		"betterComplexity": "Time O(N*L*logN), Space O(1)."
	}
]
