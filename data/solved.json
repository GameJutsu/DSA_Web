[
	{
		"date": "2026-01-01",
		"number": 1929,
		"name": "Concatenation of Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> getConcatenation(vector<int>& nums) {\n        int len=nums.size();\n        vector<int> ans(len*2);\n        for(int i=0; i<len; i++){\n            ans[i]=nums[i];\n            ans[len+i]=nums[i];\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Single pass, time O(n), extra space O(n) for the duplicated array (output-sized).",
		"betterApproach": "This is already optimal; the task requires materializing the doubled array, so no asymptotically better approach exists.",
		"betterComplexity": "Time O(n), space O(n) due to required 2n output size."
	},
	{
		"date": "2026-01-01",
		"number": 66,
		"name": "Plus One",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int len=digits.size();\n        for(int i=len-1; i>=0; i--){\n            if(digits[i]!=9){\n                digits[i]+=1;\n                return digits;\n            }\n            else\n            {\n                if(i==0){\n                    digits[i]=1;\n                    digits.push_back(0);\n                }\n                else digits[i]=0;\n            }\n        }\n        return digits;\n    }\n};",
		"myComplexity": "Iterate backwards. If digit != 9, inc & return. If 9, set to 0. If i==0 is reached (all 9s thus far), set first to 1 and append 0. Time O(n), Space O(1).",
		"betterApproach": "Logic is identical, but cleaner: loop backwards, if <9 inc & return, else set to 0. If loop finishes (all 9s), handle resize/carry outside loop. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 217,
		"name": "Contains Duplicate",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<int,int> um;\n        for(int n:nums){\n            if(++um[n]>1) return true;\n        }\n        return false;\n    }\n};",
		"myComplexity": "Use unordered_map to count freqs. Loop nums, increment count. If count > 1, return true. Time O(n), Space O(n).",
		"betterApproach": "Use unordered_set to track presence, not count. Loop nums, if in set return true, else insert. Slightly less overhead than map. Time O(n), Space O(n).",
		"betterComplexity": "Time O(n), Space O(n)."
	},
	{
		"date": "2026-01-02",
		"number": 961,
		"name": "N-Repeated Element in Size 2N Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        int len=nums.size();\n        unordered_map<int,int> um;\n        for(int i=0; i<len; i++){\n            if(++um[nums[i]]>1) return nums[i];\n        }\n        return -1;\n    }\n};",
		"myComplexity": "Use unordered_map to count freqs. Loop array, increment count. First element to reach count 2 is the answer (since only one repeats). Time O(N), Space O(N).",
		"betterApproach": "Exploit density (element is 50% of array). Check neighbors: nums[i] == nums[i-1] or nums[i-2]. By Pigeonhole Principle, duplicate must appear within distance 2. Time O(N), Space O(1).",
		"betterComplexity": "Time O(N), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 242,
		"name": "Valid Anagram",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        vector<int> vs(26,0), vt(26,0);\n        for(char c:s){\n            vs[c-'a']++;\n        }\n        for(char c:t){\n            vt[c-'a']++;\n        }\n        return vs==vt;\n    }\n};",
		"myComplexity": "Create two freq vectors of size 26. Populate vs for s, vt for t. Return vs==vt. Time O(n), Space O(1).",
		"betterApproach": "Use single freq vector. Check lengths equal. Inc for s, dec for t. If any count < 0 (or !=0 at end), false. Saves one pass and half space. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-02",
		"number": 1,
		"name": "Two Sum",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int len=nums.size();\n        unordered_map<int,int> um;\n        for(int i=0; i<len; i++){\n            if(um[target-nums[i]]) return {um[target-nums[i]]-1, i};\n            else{\n                um[nums[i]]=i+1;\n            }\n        }\n        return {};\n    }\n};",
		"myComplexity": "Iterate once. Store value->index+1. Check if target-val exists. Return indices. Time O(n), Space O(n).",
		"betterApproach": "This is already the optimal one-pass hash table approach. No asymptotic improvement possible.",
		"betterComplexity": "Time O(n), Space O(n)."
	},
	{
		"date": "2026-01-02",
		"number": 14,
		"name": "Longest Common Prefix",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string ans=strs[0];\n        for(string s:strs){\n            string newAns=\"\";\n            int ansL=ans.size(), currL=s.size();\n            for(int i=0; i<ansL, i<currL; i++){\n                if(ans[i]==s[i]) newAns+=ans[i];\n                else break;\n            }\n            if(newAns==\"\") return \"\";\n            ans=newAns;\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Init ans=strs[0]. Loop others, compare with ans char-by-char, rebuilding newAns. Update ans. Time O(S) (sum of chars), Space O(S) (temp strings).",
		"betterApproach": "Sort the strings. Compare only the first and last string (smallest & largest lexicographically). The common prefix of these two is the answer for all. Time O(N*L*logN), Space O(1).",
		"betterComplexity": "Time O(N*L*logN), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 49,
		"name": "Group Anagrams",
		"difficulty": "Medium",
		"code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        map<vector<int>,vector<string>> mp;\n        for(string s:strs){\n            vector<int> curr(26,0);\n            for(char c:s){\n                curr[c-'a']++;\n            }\n            mp[curr].push_back(s);\n        }\n        vector<vector<string>> ans;\n        for(auto i:mp){\n            ans.push_back(i.second);\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Use std::map with vector<int> keys (freq counts). Calculate count per string, group in map. Return values. Time O(N*K log N), Space O(N*K).",
		"betterApproach": "Use unordered_map for O(1) avg access. Key can be a generated string (e.g. '1#0#2...') or custom hash for vector<int>. Reduces time to O(N*K).",
		"betterComplexity": "Time O(N*K), Space O(N*K)."
	},
	{
		"date": "2026-01-03",
		"number": 1470,
		"name": "Shuffle the Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int i=0, j=n, curr=0;\n        vector<int> ans(2*n);\n        while(i<n && j<2*n){\n            ans[curr++]=nums[i++];\n            ans[curr++]=nums[j++];\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Two pointers: i=0, j=n. Create ans vector size 2n. Loop, placing nums[i] then nums[j] into ans. Time O(n), Space O(n).",
		"betterApproach": "For O(1) space (if constraints allow), pack two nums into one integer (e.g., using bit shifting: val = x + (y << 10)) in-place, then unpack in a second pass. Time O(n), Space O(1).",
		"betterComplexity": "Time O(N), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 485,
		"name": "Max Consecutive Ones",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    int findMaxConsecutiveOnes(vector<int>& nums) {\n        int len=nums.size(), i=0, ans=0, curr;\n        while(i<len){\n            curr=0;\n            while(i<len && nums[i]==1){\n                curr++;\n                i++;\n            }\n            while(i<len && nums[i]==0){\n                i++;\n            }\n            ans=max(ans, curr);\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Iterate with index i. Inner loop: count 1s to curr. Update max. Inner loop: skip 0s. Time O(n), Space O(1).",
		"betterApproach": "Single pass. If 1: curr++, max = max(ans, curr). If 0: curr = 0. Simpler logic but same complexity. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 645,
		"name": "Set Mismatch",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> findErrorNums(vector<int>& nums) {\n        int len=nums.size(), rep, miss;\n        vector<int> cnt(len+1, 0);\n        for(int n:nums){\n            cnt[n]++;\n        }\n        for(int i=1; i<len+1; i++){\n            if(cnt[i]==2) rep=i;\n            if(cnt[i]==0) miss=i;\n        }\n        return {rep, miss};\n    }\n};",
		"myComplexity": "Use freq array size n+1. Count occurrences. Index with count 2 is Rep, count 0 is Miss. Time O(n), Space O(n).",
		"betterApproach": "Math approach: Calc diff of Sums (S - A = miss - dup) and diff of Square Sums (S2 - A2 = miss^2 - dup^2). Solve system of eqns. Or use Array Marking (negating indices). Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 1365,
		"name": "How Many Numbers Are Smaller Than the Current Number",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        int len=nums.size(), curr;\n        vector<int> ans(len);\n        for(int i=0; i<len; i++){\n            curr=0;\n            for(int j=0; j<len; j++){\n                if(nums[j]<nums[i]) curr++;\n            }\n            ans[i]=curr;\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Brute force: Nested loops. For each element i, counting how many j exist where nums[j] < nums[i]. Time O(n^2), Space O(n).",
		"betterApproach": "Buckets/Prefix Sum (since values <=100): Count freqs in array size 101. Compute prefix sums (count[i] += count[i-1]). count[val-1] is the result. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 448,
		"name": "Find All Numbers Disappeared in an Array",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int len=nums.size();\n        vector<int> cnt(len+1, 0), ans;\n        for(int n:nums){\n            cnt[n]++;\n        }\n        for(int i=1; i<=len; i++){\n            if(cnt[i]==0) ans.push_back(i);\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Create freq vector size len+1. Count occurrences. Indices 1..len with 0 count are missing, add to ans. Time O(n), Space O(n).",
		"betterApproach": "In-place marking: For each val, negate nums[abs(val)-1]. Second pass: if nums[i] > 0, then i+1 is missing. No extra space. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 27,
		"name": "Remove Element",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int i=0, j=0, len=nums.size(), ans=0;\n        while(i<len && j<len){\n            while(j<len && nums[j]==val){\n                j++;\n                ans++;\n            }\n            if(i<len && j<len) nums[i++]=nums[j++];\n        }\n        return len-ans;\n    }\n};",
		"myComplexity": "Two pointers. Pointer j scans and skips 'val'. Pointer i overwrites valid numbers. Count removals. Time O(n), Space O(1).",
		"betterApproach": "Standard approach: Loop j through array. If nums[j] != val, assign nums[i] = nums[j] and inc i. Return i. Simpler logic, same complexity. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 169,
		"name": "Majority Element",
		"difficulty": "Easy",
		"code": "class Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int len=nums.size();\n        unordered_map<int,int> um;\n        for(int n:nums){\n            if(++um[n] > len/2) return n;\n        }\n        return -1;\n    }\n};",
		"myComplexity": "Use map to count freqs. If count > n/2, return element. Time O(n), Space O(n).",
		"betterApproach": "Boyer-Moore Voting Algorithm: Maintain candidate and count. If count=0, new candidate. If match, count++, else count--. Final candidate is majority. Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-03",
		"number": 705,
		"name": "Design HashSet",
		"difficulty": "Easy",
		"code": "class MyHashSet {\npublic:\n    vector<bool> v = vector<bool>(1e6+1, false);\n    MyHashSet() {\n    }\n    \n    void add(int key) {\n        v[key]=true;\n    }\n    \n    void remove(int key) {\n        v[key]=false;\n    }\n    \n    bool contains(int key) {\n        return v[key];\n    }\n};",
		"myComplexity": "Direct Mapping: Use bool vector size 1e6+1. Key is index. O(1) ops. Space O(1) (fixed max range).",
		"betterApproach": "Chaining (Generic): Vector of Linked Lists (Buckets). Hash key to bucket index. Handle collisions by searching list. Better for sparse/infinite ranges. Time O(1) avg, Space O(K).",
		"betterComplexity": "Time O(1) avg, Space O(K)."
	},
	{
		"date": "2026-01-03",
		"number": 706,
		"name": "Design HashMap",
		"difficulty": "Easy",
		"code": "class MyHashMap {\npublic:\n    vector<int> v = vector<int> (1e6+1, -1);\n    MyHashMap() {\n        \n    }\n    \n    void put(int key, int value) {\n        v[key]=value;\n    }\n    \n    int get(int key) {\n        return v[key];\n    }\n    \n    void remove(int key) {\n        v[key]=-1;\n    }\n};",
		"myComplexity": "Direct Mapping: Use int vector size 1e6+1, init to -1. Key is index. O(1) ops. Space O(1) (fixed max range).",
		"betterApproach": "Chaining: Array of Lists (key-value pairs). Hash key to bucket. More memory efficient for sparse keys. Time O(1) avg, Space O(N).",
		"betterComplexity": "Time O(1) avg, Space O(N)."
	},
	{
		"date": "2026-01-03",
		"number": 75,
		"name": "Sort Colors",
		"difficulty": "Medium",
		"code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int r=0, w=0, b=0, i=0;\n        for(int n:nums){\n            if(n==0) r++;\n            else if(n==1) w++;\n            else b++;\n        }\n        while(r--) nums[i++]=0;\n        while(w--) nums[i++]=1;\n        while(b--) nums[i++]=2;\n    }\n};",
		"myComplexity": "Counting Sort: Two passes. First, count r, w, b. Second, overwrite array with 0s then 1s then 2s. Time O(n), Space O(1).",
		"betterApproach": "Dutch National Flag: One pass. 3 pointers (low, mid, high). If 0, swap(low++, mid++). If 1, mid++. If 2, swap(mid, high--). Time O(n), Space O(1).",
		"betterComplexity": "Time O(n), Space O(1)."
	},
	{
		"date": "2026-01-04",
		"number": 347,
		"name": "Top K Frequent Elements",
		"difficulty": "Medium",
		"code": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        map<int, vector<int>, greater<int>> mp;\n        unordered_map<int, int> um;\n        int len=nums.size();\n        vector<int> ans;\n        for(int i=0; i<len; i++){\n            um[nums[i]]++;\n        }\n        for(auto i:um){\n            mp[i.second].push_back(i.first);\n        }\n        for(auto i:mp){\n            for(int x:i.second){\n                ans.push_back(x);\n                if(!--k) return ans;\n            }\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Count freq in unordered_map. Push to std::map<count, vector<nums>> (sorted by key desc). Iterate map to harvest top k. Time O(N log N) (map inserts), Space O(N).",
		"betterApproach": "Bucket Sort: Since freq <= N, create array of buckets[count]. Fill buckets. Iterate backwards from N to 1 to find top k. Time O(N), Space O(N). (Alt: Min-Heap size k is O(N log K)).",
		"betterComplexity": "Time O(N), Space O(N)."
	},
	{
		"date": "2026-01-04",
		"number": 238,
		"name": "Product of Array Except Self",
		"difficulty": "Medium",
		"code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int len=nums.size(), pl=1, pr=1;\n        vector<int> l(len), r(len), ans(len);\n        for(int i=0; i<len; i++){\n            l[i]=pl;\n            r[len-1-i]=pr;\n            pl*=nums[i];\n            pr*=nums[len-1-i];\n        }\n        for(int i=0; i<len; i++){\n            pl=(i==0)?1:l[i];\n            pr=(i==len-1)?1:r[i];\n            ans[i]=pl*pr;\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Calculate separate Prefix Product array and Suffix Product array. ans[i] = pre[i] * suf[i]. Time O(N), Space O(N) (extra arrays).",
		"betterApproach": "Optimize Space: Write prefix products directly into ans array. Then iterate backwards with a scalar 'suffix' variable, multiplying into ans[i]. Time O(N), Space O(1) (aux).",
		"betterComplexity": "Time O(N), Space O(1) (aux)."
	},
	{
		"date": "2026-01-04",
		"number": 1390,
		"name": "Four Divisors",
		"difficulty": "Medium",
		"code": "class Solution {\npublic:\n    int divC(int n){\n        int div=0, sum=0;\n        unordered_set<int> s;\n        for(int i=1; i*i<=n; i++){\n            if(n%i==0){\n                s.insert(i);\n                s.insert(n/i);\n            }\n        }\n        if(s.size()==4){\n            for(int i:s){\n                sum+=i;\n            }\n        }\n        else sum=-1;\n        return sum;\n    }\n\n    int sumFourDivisors(vector<int>& nums) {\n        int ans=0;\n        for(int i=0; i<nums.size(); i++){\n            cout<<nums[i]<<\" \"<<divC(nums[i])<<endl;\n            if(divC(nums[i])!=-1) ans+=divC(nums[i]);\n        }\n        return ans;\n    }\n};",
		"myComplexity": "Iterate 1 to sqrt(n). If divides, add i and n/i to set. If set size is 4, add to sum. Iterate for all nums. Time O(N*sqrt(val)), Space O(1).",
		"betterApproach": "Same iteration limit. Count factors directly without Set overhead. If count > 4, break early. Sum if count exactly 4. (Case: p^3 or p*q). Time O(N*sqrt(val)), Space O(1).",
		"betterComplexity": "Time O(N*sqrt(val)), Space O(1)."
	}
]
